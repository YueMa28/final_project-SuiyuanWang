---
title: "Mapping fine-scale population using dasymetric method"
author: Suiyuan Wang
subtitle: A case study in Buffalo city, NY
---

# Introduction

Knowledge of the fine-level population distribution is vital for measuring the impacts of socio-economic justice, optimizing resource allocation, and assessing the risks of environmental exposures. The traditional way to get population data is from the census bureau. However, population data released by the census bureau are too coarse and irregular to satisfy the requirements of accurate analysis. To solve the irregular shape and too coarse level problem of census data, we would downscale the census block group level data to census block. As for the method, the dasymetric method would be applied.  The dasymetric method uses locality knowledge to depict the uneven population distribution within zones without assuming even distributions. This volume preserve method disaggregates the population within the source zone to the target zones according to the weighted layer generated by population-related ancillary information to preserve the total population count. The dasymetric method has been evaluated as an effective and feasible way for population disaggregation. Finally, the result will be evaluated comparing with census block data. Overall, this project aims to apply the dasymetric method to disaggregate census data to get fine-level population data using open-source data.

# Materials and methods

```{r, message=F, warning=F}
require(sf)
library(remotes)
install_github("JaFro96/dasymetric")
require(dasymetric)
library(leaflet)
library(kableExtra)
library(piggyback)
library(tmap) 
library(lwgeom)
knitr::opts_chunk$set(cache=TRUE)  # cache the results for quick compiling
```

1. Download data 
* Census boundaries (2020) with population. 
 * Census block population_block
 * Census block group population_bg
* Microsoft building footprint (2018).
* Buffalo zoning data
```{r}
dataurl = "https://github.com/geo511-2022/final_project-SuiyuanWang/releases/download/v1.0.2/Data_GEO511_project.zip"

#tdir=tempdir()
#download.file(dataurl,destfile=file.path(tdir,"temp.zip"))
#unzip(file.path(tdir,"temp.zip"),exdir = tdir) #unzip the compressed folder

download.file(dataurl,"temp.zip")
unzip("temp.zip") #unzip the compressed folder
```
```{r}
#' Create a dasymetric map
#'
#' @description Binary dasymetric mapping that uses urban areas to make more valuable predictions on population counts
#'
#' @import graphics
#' @importFrom rlang .data
#'
#' @param target sf object containing geometry of the desired spatial zones
#' @param source sf object that we want to interpolate
#' @param ancillary_data sf object containing geometry that helps to better interpolate (i.e. land use, building footprints)
#' @param tid Optional string denoting column with unique identifier for `target` geometries. Optional, and will otherwise be automatically generated
#' @param extensive Required atomic vector of strings denoting columns in `source` with extensive variables (i.e. count data)
#'
#' @return sf
#' @export
#'
#' @source <https://github.com/slu-openGIS/areal/pull/27/commits/d86490f6544af4235bdbdf5f51a9cab000d2b78e>
#'
#' @examples
#' source_geom = sf::st_union(population_counts)
#' source=sf::st_sf(ID=1,population=sum(population_counts["population"]$population),source_geom)
#' urban = prep_landuse(corine_18)
#' dasymetric_map(population_counts, source, urban, extensive = "population")
dasymetric_map <- function(target, source, ancillary_data, tid = NULL, extensive = NULL) {

  # Add IDs
  if(missing(tid)){
    target[['AW_tid']] <- 1:nrow(target)
    tid <- 'AW_tid'
  }
  source[['AW_sid']] <- 1:nrow(source)

  # Intersect Source to Intermediate
  first_int <- sf::st_intersection(source, ancillary_data)

  # Generate ID for Intersection
  first_int['AW_fid'] <- 1:nrow(first_int)

  # Compute Area for First Interpolation
  first_int['AW_area'] <- sf::st_area(first_int)

  # Calculate Area as a Proportion of Source Area
  cov_area <- first_int |>
    sf::st_drop_geometry() |>
    dplyr::group_by(.data$AW_sid) |>
    dplyr::summarise(AW_cov_area = sum(.data$AW_area))

  first_int <- dplyr::left_join(first_int, cov_area, by = 'AW_sid')
  first_int['AW_area_prp'] <- as.numeric(first_int$AW_area / first_int$AW_cov_area)

  # Multiply Extensive Variables by this Proportion
  for(i in extensive){
    first_int[[i]] <- first_int[[i]] * first_int[['AW_area_prp']]
  }

  # Intersect Again, Intermediate to Target
  target_int <- sf::st_intersection(first_int, target)

  # Calculate New Area (And Ratio)
  target_int['AW_t_area'] <- sf::st_area(target_int)
  target_int['AW_t_prp'] <- as.numeric(target_int[['AW_t_area']] / target_int[['AW_area']])

  # Multiply Extensive Again
  for(i in extensive){
    target_int[[i]] <- target_int[[i]] * target_int[['AW_t_prp']]
  }

  # Group And Summarise Extensive
  summary <- target_int |>
    sf::st_drop_geometry() |>
    dplyr::group_by(!!dplyr::sym(tid)) |>
    dplyr::summarise_at(extensive, sum)

  # Join To Target
  target <- dplyr::left_join(target, summary, by = tid)

  return(target)
}
```


```{r}
landuse <- st_read("Data_GEO511_project/zoning.shp") 
source_geom <- st_read("Data_GEO511_project/census_bg.shp")
target_geom <- st_read("Data_GEO511_project/census_block.shp")
residential_bf <- st_read("Data_GEO511_project/residential_bf.shp")
# Create directory path
#dsn_zoning <- file.path(tdir, "Data_GEO511_project", "zoning.shp")
#dsn_census_bg <- file.path(tdir, "Data_GEO511_project", "census_bg.shp") 
#dsn_census_block <- file.path(tdir, "Data_GEO511_project","census_block.shp") 
#dsn_residential_bf <- file.path(tdir, "Data_GEO511_project","residential_bf.shp") 

# Buffalo city zoning data (Landuse), source (block group), target (block)
#landuse <- st_read(dsn_zoning) 
#source_geom <- st_read(dsn_census_bg)
#target_geom <- st_read(dsn_census_block)
#residential_bf <- st_read(dsn_residential_bf)
# ancillary data (building footprint)
#bf <- st_read("Data_GEO511_project/building.shp")
```
```{r}
#library(RColorBrewer)
#cols <- brewer.pal(7, "YlOrRd")

# plot(dm_pop["Population"],col = alpha(cols, 0.9), main="Buffalo city Population at Census Block Group (2020)")

#tm_shape(source_geom) +
# tm_fill(col = "population", style = "jenks", size = 0.5, title = "Population") +
# tm_layout(title = "Buffalo city Population at Census Block Group (2020)") +
# tmap_mode("view")

#st_crs(bf)
#st_crs(target_geom)
#st_crs(source_geom)
#st_crs(landuse)
```


2. Clean required data

###filter landuse as residential, using residential landuse to filter building footprint
### find [zoning codes](https://data.buffalony.gov/Economic-Neighborhood-Development/Zoning/5843-jknb) related to residential: 
residential_code = c('N-2R', 'N-3R', 'N-4-30', 'N-4-50', 'D-R')
residential <- landuse %>% filter(gcode == residential_code) 

residential_wgs84  <- residential %>%  st_transform(4326) 

#library(sf)
#bf_wgs84 <- poly2nb(st_make_valid(bf))
#residential_wgs84 <- poly2nb(st_make_valid(residential_wgs84))
sf_use_s2(FALSE)

#residential_bf <- st_intersects(bf, residential_wgs84)

#residential_bf

set same projection for geometries. 
```{r dasymetric, warning=FALSE, message=FALSE}
target_geom_wgs84  <- target_geom %>%  st_transform(4326) 
source_geom_wgs84  <- source_geom %>%  st_transform(4326) 

# dasymetric map with landuse information as ancillary data
sf_use_s2(FALSE)

dm_pop = dasymetric_map(target_geom_wgs84, source_geom_wgs84, residential_bf, extensive = "population")

# convert estimation result to integer, and replace NA as 0.
dm_pop[is.na(dm_pop)] <- 0 
dm_pop$population = as.integer(dm_pop$population)
```

# Results

Evaluating the result by plotting ground truth data and estimation result. Then, calculate R2 and coefficients.
[REFER TO] (https://lukemiller.org/index.php/2012/10/adding-p-values-and-r-squared-values-to-a-plot-using-expression/)
```{r}
#calculate r2 in dm_pop, 'population'(estimate) & 'Population'(ground truth)
mod1 = lm(Population~population, data = dm_pop)
modsum = summary(mod1)
plot(dm_pop$Population, dm_pop$population, type = 'p', las = 1,
		xlab = expression(paste('Census block Population')),
		ylab = 'Estimate population')

#adding the regression line from the linear model
abline(mod1)
```

```{r}
r2 = modsum$adj.r.squared
print(paste("R2 = ", r2))
```

```{r}
modsum$coefficients
```

Mapping. We are using `tmap` to show the ground truth and estimation result in a interactive map. By exploring the map, we can easily find the outliner location and discuss the reason.
```{r}
tm_shape(dm_pop) +
  tm_fill(col = c("population", "Population"), 
          style = "jenks", 
          title = c("Estimate_Population", "True_Population")) + 
  tm_facets(ncol = 2, sync = TRUE) +
  tmap_mode("view")
```


# Conclusions

[~200 words]

Clear summary adequately describing the results and putting them in context. Discussion of further questions and ways to continue investigation.

# References

All sources are cited in a consistent manner

